{
  "_args": [
    [
      {
        "raw": "cppo-actual@git://github.com/npm-opam/cppo.git#1.4.1",
        "scope": null,
        "escapedName": "cppo-actual",
        "name": "cppo-actual",
        "rawSpec": "git://github.com/npm-opam/cppo.git#1.4.1",
        "spec": "git://github.com/npm-opam/cppo.git#1.4.1",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:npm-opam/cppo.git#1.4.1",
          "sshUrl": "git+ssh://git@github.com/npm-opam/cppo.git#1.4.1",
          "httpsUrl": "git+https://github.com/npm-opam/cppo.git#1.4.1",
          "gitUrl": "git://github.com/npm-opam/cppo.git#1.4.1",
          "shortcut": "github:npm-opam/cppo#1.4.1",
          "directUrl": "https://raw.githubusercontent.com/npm-opam/cppo/1.4.1/package.json"
        }
      },
      "/Users/ryan/Personal/proj/bs-node-http-server/node_modules/@opam-alpha/cppo"
    ]
  ],
  "_from": "git://github.com/npm-opam/cppo.git#f93baf17d8099c5866df939264ddddb6457aa7d2",
  "_id": "cppo-actual@1.4.1",
  "_inCache": true,
  "_location": "/cppo-actual",
  "_phantomChildren": {},
  "_requested": {
    "raw": "cppo-actual@git://github.com/npm-opam/cppo.git#1.4.1",
    "scope": null,
    "escapedName": "cppo-actual",
    "name": "cppo-actual",
    "rawSpec": "git://github.com/npm-opam/cppo.git#1.4.1",
    "spec": "git://github.com/npm-opam/cppo.git#1.4.1",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:npm-opam/cppo.git#1.4.1",
      "sshUrl": "git+ssh://git@github.com/npm-opam/cppo.git#1.4.1",
      "httpsUrl": "git+https://github.com/npm-opam/cppo.git#1.4.1",
      "gitUrl": "git://github.com/npm-opam/cppo.git#1.4.1",
      "shortcut": "github:npm-opam/cppo#1.4.1",
      "directUrl": "https://raw.githubusercontent.com/npm-opam/cppo/1.4.1/package.json"
    }
  },
  "_requiredBy": [
    "/@opam-alpha/cppo"
  ],
  "_resolved": "git://github.com/npm-opam/cppo.git#f93baf17d8099c5866df939264ddddb6457aa7d2",
  "_shasum": "aefb2af472d103c267f1e4b2d34d20fc1f452375",
  "_shrinkwrap": null,
  "_spec": "cppo-actual@git://github.com/npm-opam/cppo.git#1.4.1",
  "_where": "/Users/ryan/Personal/proj/bs-node-http-server/node_modules/@opam-alpha/cppo",
  "dependencies": {
    "@opam-alpha/ocamlbuild": "*",
    "@opam-alpha/ocamlfind": "*",
    "dependency-env": "*",
    "nopam": "*",
    "opam-installer-bin": "git+https://github.com/yunxing/opam-installer-bin.git",
    "substs": "git+https://github.com/yunxing/substs.git"
  },
  "description": "Cppo: cpp for OCaml ===================",
  "devDependencies": {},
  "exportedEnvVars": {
    "CAML_LD_LIBRARY_PATH": {
      "global": true,
      "resolveAsRelativePath": true,
      "globalCollisionBehavior": "joinPath",
      "val": "./_build/ocamlfind/lib/stublibs"
    },
    "version": {
      "global": true,
      "globalCollisionBehavior": "clobber",
      "val": "1.4.1"
    },
    "FINDLIB": {
      "global": true,
      "resolveAsRelativePath": true,
      "globalCollisionBehavior": "joinPath",
      "val": "./_build/ocamlfind/lib"
    },
    "cppo_installed": {
      "global": true,
      "globalCollisionBehavior": "clobber",
      "val": "true"
    },
    "cppo_enable": {
      "global": true,
      "globalCollisionBehavior": "clobber",
      "val": "enable"
    },
    "cppo_version": {
      "global": true,
      "globalCollisionBehavior": "clobber",
      "val": "1.4.1"
    },
    "PATH": {
      "global": true,
      "resolveAsRelativePath": true,
      "globalCollisionBehavior": "joinPath",
      "val": "./_build/ocamlfind/bin"
    }
  },
  "gitHead": "f93baf17d8099c5866df939264ddddb6457aa7d2",
  "name": "cppo-actual",
  "optionalDependencies": {},
  "peerDependencies": {
    "@opam-alpha/ocaml": ">= 4.2.3"
  },
  "readme": "Cppo: cpp for OCaml\n===================\n\nCppo is an equivalent of the C preprocessor for OCaml programs.\nIt allows the definition of simple macros and file inclusion.\n\nCppo is:\n\n* more OCaml-friendly than cpp\n* easy to learn without consulting a manual\n* reasonably fast\n* simple to install and to maintain\n\nUser guide\n----------\n\nCppo is a preprocessor for programming languages that follow lexical rules\ncompatible with OCaml.\n\nCppo supports a number of directives. A directive is a `#` sign placed\nat the beginning of a line, possibly preceded by some whitespace, and followed\nby a valid directive name or by a number:\n\n```ocaml\nBLANK* \"#\" BLANK* (\"define\"|\"undef\"\n                  |\"if\"|\"ifdef\"|\"ifndef\"|\"else\"|\"elif\"|\"endif\"\n                  |\"include\"\n                  |\"warning\"|\"error\"\n                  |\"ext\"|\"endext\") ...\n```\n\nDirectives can be split into multiple lines by placing a backslash `\\` at\nthe end of the line to be continued. In general, any special character\ncan used as a normal character by preceding it with backslash.\n\n\nFile inclusion\n--------------\n\n```ocaml\n#include \"hello.ml\"\n```\n\nThis is how a source file `hello.ml` can be included.\nRelative paths are searched first in the directory of the current file\nand then in the search paths added on the command line using `-I`, if any.\n\n\nMacros\n------\n\nThis is a simple macro that doesn't take an argument (\"object-like\nmacro\" in the cpp jargon):\n\n```ocaml\n#define Ms Mississippi\n\nmatch state with\n    Ms -> true\n  | _ -> false\n```\n\nAfter preprocessing by cppo, the code above becomes:\n\n```ocaml\nmatch state with\n    Mississippi -> true\n  | _ -> false\n```\n\nIf needed, defined macros can be undefined. This is required prior to\nredefining a macro:\n\n```ocaml\n#undef X\n```\n\nAn important distinction with cpp is that only previously-defined\nmacros are accessible. Defining, undefining or redefining a macro has\nno effect on how previous macros will expand.\n\nMacros can take arguments (\"function-like macro\" in the cpp\njargon). Both in the definition (`#define`) and in macro application the\nopening parenthesis must stick to the macro's identifier:\n\n```ocaml\n#define debug(args) if !debugging then Printf.eprintf args else ()\n\ndebug(\"Testing %i\" (1 + 1))\n```\n\nis expanded into:\n\n```ocaml\nif !debugging then Printf.eprintf \"Testing %i\" (1 + 1) else ()\n```\n\nHere is a multiline macro definition. Newlines occurring between\ntokens must be protected by a backslash:\n\n```ocaml\n#define repeat_until(action,condition) \\\n  action; \\\n  while not (condition) do \\\n    action \\\n  done\n```\n\nAll user-definable macros are constant. There are however two\npredefined variable macros: `__FILE__` and `__LINE__` which take the value\nof the position in the source file where the macro is being expanded.\n\n```ocaml\n#define loc (Printf.sprintf \"File %S, line %i\" __FILE__ __LINE__)\n```\n\nMacros can be defined on the command line as follows:\n\n```ocaml\n# preprocessing only\ncppo -D 'VERSION 1.0' example.ml\n\n# preprocessing and compiling\nocamlopt -c -pp \"cppo -D 'VERSION 1.0'\" example.ml\n```\n\nConditionals\n------------\n\nHere is a quick reference on conditionals available in cppo. If you\nare not familiar with `#ifdef`, `#ifndef`, `#if`, `#else` and `#elif`, please\nrefer to the corresponding section in the cpp manual.\n\n```ocaml\n#ifndef VERSION\n#warning \"VERSION is undefined\"\n#define VERSION \"n/a\"\n#endif\n#ifndef VERSION\n#error \"VERSION is undefined\"\n#endif\n#if OCAML_MAJOR >= 3 && OCAML_MINOR >= 10\n...\n#endif\n#ifdef X\n...\n#elif defined Y\n...\n#else\n...\n#endif\n```\n\nThe boolean expressions following `#if` and `#elif` may perform arithmetic\noperations and tests over 64-bit ints.\n\nBoolean expressions:\n\n* `defined` ...  followed by an identifier, returns true if such a macro exists\n* `true`\n* `false`\n* `(` ... `)`\n* ... `&&` ...\n* ... `||` ...\n* `not` ...\n\nArithmetic comparisons used in boolean expressions:\n\n* ... `=` ...\n* ... `<` ...\n* ... `>` ...\n* ... `<>` ...\n* ... `<=` ...\n* ... `>=` ...\n\nArithmetic operators over signed 64-bit ints:\n\n* `(` ... `)`\n* ... `+` ...\n* ... `-` ...\n* ... `*` ...\n* ... `/` ...\n* ... `mod` ...\n* ... `lsl` ...\n* ... `lsr` ...\n* ... `asr` ...\n* ... `land` ...\n* ... `lor` ...\n* ... `lxor` ...\n* `lnot` ...\n\nMacro identifiers can be used in place of ints as long as they expand\nto an int literal or a tuple of int literals, e.g.:\n\n```ocaml\n#define one 1\n\n#if one + one <> 2\n#error \"Something's wrong.\"\n#endif\n\n#define VERSION (1, 0, 5)\n#if VERSION <= (1, 0, 2)\n#error \"Version 1.0.2 or greater is required.\"\n#endif\n```\n\nVersion strings (http://semver.org/) can also be passed to cppo on the\ncommand line. This results in multiple variables being defined, all\nsharing the same prefix. See the output of `cppo -help` (copied at the\nbottom of this page).\n\n```\n$ cppo -V OCAML:`ocamlc -version`\n#if OCAML_VERSION >= (4, 0, 0)\n(* All is well. *)\n#else\n  #error \"This version of OCaml is not supported.\"\n#endif\n```\n\nOutput:\n```\n# 2 \"<stdin>\"\n(* All is well. *)\n```\n\nSource file location\n--------------------\n\nLocation directives are the same as in OCaml and are echoed in the\noutput. They consist of a line number optionally followed by a file name:\n\n```ocaml\n# 123\n# 456 \"source\"\n```\n\nMessages\n--------\n\nWarnings and error messages can be produced by the preprocessor:\n\n```ocaml\n#ifndef X\n  #warning \"Assuming default value for X\"\n  #define X 1\n#elif X = 0\n  #error \"X may not be null\"\n#endif\n```\n\nCalling an external processor\n-----------------------------\n\nCppo provides a mechanism for converting sections of a file using\nand external program. Such a section must be placed between `#ext` and\n`#endext` directives.\n\n```bash\n$ cat foo\nABC\n#ext lowercase\nDEF\n#endext\nGHI\n#ext lowercase\nKLM\nNOP\n#endext\nQRS\n\n$ cppo -x lowercase:'tr \"[A-Z]\" \"[a-z]\"' foo\n# 1 \"foo\"\nABC\ndef\n# 5 \"foo\"\nGHI\nklm\nnop\n# 10 \"foo\"\nQRS\n```\n\nIn the example above, `lowercase` is the name given on the\ncommand-line to external command `'tr \"[A-Z]\" \"[a-z]\"'` that reads\ninput from stdin and writes its output to stdout.\n\n\nEscaping\n--------\n\nThe following characters can be escaped by a backslash when needed:\n\n```ocaml\n(\n)\n,\n#\n```\n\nIn OCaml `#` is used for method calls. It is usually not a problem\nbecause in order to be interpreted as a preprocessor directive, it\nmust be the first non-blank character of a line and be a known\ndirective. If an object has a define method and you want `#` to appear\nfirst on a line, you would have to use `\\#` instead:\n\n```ocaml\nobj\n  \\#define\n```\n\nLine directives in the usual format supported by OCaml are correctly\ninterpreted by cppo.\n\nComments and string literals constitute single tokens even when they\nspan across multiple lines. Therefore newlines within string literals\nand comments should remain as-is (no preceding backslash) even in a\nmacro body:\n\n```ocaml\n#define welcome \\\n\"**********\n*Welcome!*\n**********\n\"\n```\n\nConcatenation\n-------------\n\n`CONCAT()` is a predefined macro that takes two arguments, removes any\nwhitespace between and around them and fuses them into a single identifier.\nThe result of the concatenation must be a valid identifier of the\nform [A-Za-z_][A-Za-z0-9_]+ or [A-Za-z], or empty.\n\nFor example,\n\n```ocaml\n#define x 123\nCONCAT(z, x)\n```\n\nexpands into:\n\n```ocaml\nz123\n```\n\nHowever the following is illegal:\n\n```ocaml\n#define x 123\nCONCAT(x, z)\n```\n\nbecause 123z does not form a valid identifier.\n\n`CONCAT(a,b)` is roughly equivalent to `a##b` in cpp syntax.\n\n\nStringification\n---------------\n\n`STRINGIFY()` is a predefined macro that takes one argument,\nremoves any leading and trailing whitespace, reduces each internal\nwhitespace sequence to a single space character and produces\na valid OCaml string literal.\n\nFor example,\n\n```ocaml\n#define TRACE(f) Printf.printf \">>> %s\\n\" STRINGIFY(f); f\nTRACE(print_endline) \"Hello\"\n```\n\nis expanded into:\n\n```ocaml\nPrintf.printf \">>> %s\\n\" \"print_endline\"; print_endline \"Hello\"\n```\n\n`STRINGIFY(x)` is the equivalent of `#x` in cpp syntax.\n\n\nOcamlbuild plugin\n------------------\n\nAn ocamlbuild plugin is available. To use it, you can call ocamlbuild\nwith the argument `-plugin-tag package(cppo_ocamlbuild)` (only since\n4.01).\n\nWith Oasis :\n```\nOCamlVersion: >= 4.01\nAlphaFeatures: ocamlbuild_more_args\nXOCamlbuildPluginTags: package(cppo_ocamlbuild)\n```\n\nAfter that, you need to add in your `myocamlbuild.ml` :\n```ocaml\nlet () =\n  Ocamlbuild_plugin.dispatch\n    (fun hook ->\n      Ocamlbuild_cppo.dispatcher hook ;\n    )\n```\n\nBy default the plugin will apply cppo on all files ending in `.cppo.ml`\n`cppo.mli`, and `cppo.mlpack`, in order to produce `.ml`, `.mli`,\nand`.mlpack` files.  The following tags are available:\n* `cppo_D(X)` ≡ `-D X`\n* `cppo_U(X)` ≡ `-U X`\n* `cppo_q` ≡ `-q`\n* `cppo_s` ≡ `-s`\n* `cppo_n` ≡ `-n`\n* `cppo_x(NAME:CMD_TEMPLATE)` ≡ `-x NAME:CMD_TEMPLATE`\n* The tag `cppo_I(foo)` can behave in two way:\n  * If `foo` is a directory, it's equivalent to `-I foo`.\n  * If `foo` is a file, it adds `foo` as a dependency and apply `-I\n    parent(foo)`.\n* `cppo_V(NAME:VERSION)` ≡ `-V NAME:VERSION`\n* `cppo_V_OCAML` ≡ `-V OCAML:VERSION`, where `VERSION`\n   is the version of OCaml that ocamlbuild uses.\n\nDetailed command-line usage and options\n---------------------------------------\n\n```\nUsage: ./cppo [OPTIONS] [FILE1 [FILE2 ...]]\nOptions:\n  -D DEF\n          Equivalent of interpreting '#define DEF' before processing the\n          input\n  -U IDENT\n          Equivalent of interpreting '#undef IDENT' before processing the\n          input\n  -I DIR\n          Add directory DIR to the search path for included files\n  -V VAR:MAJOR.MINOR.PATCH-OPTPRERELEASE+OPTBUILD\n          Define the following variables extracted from a version string\n          (following the Semantic Versioning syntax http://semver.org/):\n\n            VAR_MAJOR           must be a non-negative int\n            VAR_MINOR           must be a non-negative int\n            VAR_PATCH           must be a non-negative int\n            VAR_PRERELEASE      if the OPTPRERELEASE part exists\n            VAR_BUILD           if the OPTBUILD part exists\n            VAR_VERSION         is the tuple (MAJOR, MINOR, PATCH)\n            VAR_VERSION_STRING  is the string MAJOR.MINOR.PATCH\n            VAR_VERSION_FULL    is the original string\n\n          Example: cppo -V OCAML:4.02.1\n\n  -o FILE\n          Output file\n  -q\n          Identify and preserve camlp4 quotations\n  -s\n          Output line directives pointing to the exact source location of\n          each token, including those coming from the body of macro\n          definitions.  This behavior is off by default.\n  -n\n          Do not output any line directive other than those found in the\n          input (overrides -s).\n  -version\n          Print the version of the program and exit.\n  -x NAME:CMD_TEMPLATE\n          Define a custom preprocessor target section starting with:\n            #ext \"NAME\"\n          and ending with:\n            #endext\n\n          NAME must be a lowercase identifier of the form [a-z][A-Za-z0-9_]*\n\n          CMD_TEMPLATE is a command template supporting the following\n          special sequences:\n            %F  file name (unescaped; beware of potential scripting attacks)\n            %B  number of the first line\n            %E  number of the last line\n            %%  a single percent sign\n\n          Filename, first line number and last line number are also\n          available from the following environment variables:\n          CPPO_FILE, CPPO_FIRST_LINE, CPPO_LAST_LINE.\n\n          The command produced is expected to read the data lines from stdin\n          and to write its output to stdout.\n  -help  Display this list of options\n  --help  Display this list of options\n```\n\n\nContributing\n------------\n\nSee our contribution guidelines at\nhttps://github.com/mjambon/documents/blob/master/how-to-contribute.md\n",
  "readmeFilename": "README.md",
  "scripts": {
    "postinstall": "eval $(dependencyEnv) && nopam && make opt && make ocamlbuild && make install-lib && (opam-installer --prefix=$opam_prefix || true)"
  },
  "version": "1.4.1"
}
