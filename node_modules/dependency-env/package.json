{
  "_args": [
    [
      {
        "raw": "dependency-env@*",
        "scope": null,
        "escapedName": "dependency-env",
        "name": "dependency-env",
        "rawSpec": "*",
        "spec": "*",
        "type": "range"
      },
      "/Users/ryan/Personal/proj/bs-node-http-server"
    ]
  ],
  "_from": "dependency-env@*",
  "_id": "dependency-env@0.1.1",
  "_inCache": true,
  "_location": "/dependency-env",
  "_nodeVersion": "7.1.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/dependency-env-0.1.1.tgz_1481537512090_0.027430976275354624"
  },
  "_npmUser": {
    "name": "jordwalke",
    "email": "jordojw@gmail.com"
  },
  "_npmVersion": "3.10.9",
  "_phantomChildren": {},
  "_requested": {
    "raw": "dependency-env@*",
    "scope": null,
    "escapedName": "dependency-env",
    "name": "dependency-env",
    "rawSpec": "*",
    "spec": "*",
    "type": "range"
  },
  "_requiredBy": [
    "#DEV:/",
    "/camomile-bin",
    "/conf-m4-actual",
    "/cppo-actual",
    "/jbuilder-actual",
    "/lambda-term-bin",
    "/lwt-bin",
    "/menhir-actual",
    "/merlin-extend-actual",
    "/ocaml-migrate-parsetree-actual",
    "/ocamlBetterErrors",
    "/ocamlfind-actual",
    "/ppx_tools_versioned-actual",
    "/re-actual",
    "/react-bin",
    "/reason",
    "/reason-parser-actual",
    "/topkg-actual",
    "/utop-bin",
    "/zed-bin"
  ],
  "_resolved": "https://registry.npmjs.org/dependency-env/-/dependency-env-0.1.1.tgz",
  "_shasum": "ee95e51dba64f82a4f8d368c6591524f054b91b5",
  "_shrinkwrap": null,
  "_spec": "dependency-env@*",
  "_where": "/Users/ryan/Personal/proj/bs-node-http-server",
  "author": {
    "name": "jordwalke"
  },
  "bin": {
    "dependencyEnv": ".bin/dependencyEnv",
    "envExports": ".bin/dependencyEnv",
    "envRun": ".bin/envRun",
    "envshell": ".bin/envshell",
    "envfish": ".bin/envfish",
    "bashExportsToMake": "./bashExportsToMake"
  },
  "bugs": {
    "url": "git://github.com/reasonml/dependency-env/issues"
  },
  "dependencies": {
    "resolve": "^1.1.7"
  },
  "description": "Loads environment variables that dependencies declared as exported in their package.json",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "ee95e51dba64f82a4f8d368c6591524f054b91b5",
    "tarball": "https://registry.npmjs.org/dependency-env/-/dependency-env-0.1.1.tgz"
  },
  "engines": {
    "npm": ">=3.10.0"
  },
  "gitHead": "94c75aff3a71587afb570d89bcf2eef7996bb67f",
  "homepage": "git://github.com/reasonml/dependency-env",
  "keywords": [
    "depenency",
    "environment",
    "variables",
    "env"
  ],
  "license": "MIT",
  "maintainers": [
    {
      "name": "chenglou",
      "email": "chenglou92@gmail.com"
    },
    {
      "name": "jordwalke",
      "email": "jordojw@gmail.com"
    },
    {
      "name": "yunxing",
      "email": "nov503@gmail.com"
    }
  ],
  "name": "dependency-env",
  "optionalDependencies": {},
  "readme": "# dependency-env\n\nModularized Environment Variables.\n\nLoads environment variables that dependencies declared as exported in their package.json\n\n```sh\nnpm install --save dependency-env\n```\n\n# NOT PRODUCTION READY\n\n### Idea:\n\n> Bring the sandboxing model to environment variables.\n\n> If you add `dependency-env` to your `dependencies`, then you can eval `dependencyEnv`\n> in any of your npm `scripts`, and it will ensure that your immediate dependencies\n> (and *only* your immediate dependencies) can set environment variables that\n> are set only for the remainder of that one script.\n\nInside your package.json:\n\n```\n\"scripts\": {\n  \"doStuff\": \"eval $(dependencyEnv) && restOfCommandHere\"\n}\n```\n\nThen on the command line you can do:\n\n```\nnpm run-script doStuff\n```\n\n> Note that in these examples, `dependencyEnv` itself is not a globally installed\nbinary. When you depend on `dependency-env`, it makes sure that `dependencyEnv`\nis in `./node_modules/.bin/`, which `npm` always ensures is added to your path\nwhen for the duration of `run-script`s. This is standard `npm` behavior that\nwe're using here - we happen to be using it to be bootstrapping creating an\nenvironment that uses an (arguably) better model for constructing `PATH`s and\nany other env variable.\n\n> You might want to eval `eval $(./node_modules/.bin/dependencyEnv)` directly in your \nown build scripts because `npm run-script` has a large overhead.\n\n\n### Conventions:\n\n- Any `package.json` may include an `\"exportedEnvVars\"` field which maps\n  environment variables by their names to their respective variable configs.\n- \n- Each variable config should have a `\"val\"` field.\n- By default environment variables are scoped to the package they reside in. This means that\nthe environment variable name must be prefixed to indicate the package it was\nexported from. We do this by placing `PACKAGE_NAME__` at the beginning of each\nexported var from the `package.json` for the package named `package-name` (we\nreplace hyphens with single underscores and then include a double underscore.\nFor example, for a package named `my-package`, by default, environment\nvariables must begin with `MY_PACKAGE__`, such as `MY_PACKAGE__FOO`, or\n`MY_PACKAGE__BAR_BAR`.\n- Environment variables may declare that they are paths that should be absolute\n  paths that are resolved relative to the location of the `package.json` they\n  reside in. Set \"resolveAsRelativePath\": false\n- Environment variables may declare themselves global by including `\"global\":\n  true` in their configuration. For global variables, there is another optional\n  field called `globalCollisionBehavior` which determines how to resolve values\n  when multiple packages set the same variable name. Options are `\"fail\"`(the\n  default), `\"clobber\"`, or `\"joinPath\"` (which will combine all the values\n  from all package via `:`).\n\n- See below for examples:\n\n\n### Examples of package.json fields:\n\n```json\n  \"exportedEnvVars\": {\n    \"PATH\": {\n      \"val\": \"./src/_stage2\",\n      \"resolveAsRelativePath\": true,\n      \"global\": true,\n      \"globalCollisionBehavior\": \"joinPath\"\n    }\n    },\n    \"PACKAGE_NAME__SOME_VAR\": {\n      \"val\": \"foo\",\n      \"resolveAsRelativePath\": false\n    },\n    \"ANOTHER_GLOBALVAR\": {\n      \"val\": \"./lib/ocaml\",\n      \"resolveAsRelativePath\": true,\n      \"global\": true,\n      \"globalCollisionBehavior\": \"fail\"\n    }\n  },\n```\n\n\n### Motivation:\n\n`npm`'s run-script has a great feature that will augment the `PATH` environment\nvariable to include `/node_modules/.bin`, only for the duration of the\nrun-script. This is great because it means changing of paths is *scoped* to a\nparticular duration, and in a predefined way that your *dependencies* get to\ninfluence. But there are some shortcomings of `npm` `run-script`, and some ways\nthat we can take the idea further beyond simply augmenting a `PATH`, but\nsetting and augmenting arbitrary environment variables.\n\n- `npm` `run-script` only modifies the `PATH` and only for the sake of setting\n  up `bin`. Dependencies might want to set other environment variables.\n- `npm` `run-script` is slow (often hundreds of `ms` overhead to startup).\n  Let's not be slow. The examples here demonstrate using `dependency-env` with\n  `run-script` in this doc are merely for convenience. `dependency-env`\n  provides a way to not *need* `run-script` to correctly wire up paths to\n  binaries that your deps publish if your dependencies configure `PATH` using\n  `dependency-env`.\n- On windows, `npm`'s `bin` features might only be able to link entire directories,\n  not specific binary files (on some network mount file systems). It's not like\n  `dependency-env` works on windows, but it could pretty easily and it's set up\n  to do that since it doesn't rely on symlinks.\n- `npm`'s `bin` feature allows you to rely on binaries produced by your transitive\n  dependencies. Those transitive dependencies might be implementation details of your\n  immediate dependencies, and they're likely to change and break you. `dependency-env`\n  enforces that you've declared pacakges as dependencies in order for those\n  dependencies to contribute to your scripts' `dependency-env` environment.\n- `npm`'s `bin` feature requires that you list the binaries to expose, before\n  your `postinstall` script even runs. Furthermore, those binaries need to\n  *exist* before the `postinstall` is executed. That's not good for compiled\n  packages because `postinstall` is the thing that will generate those binaries.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/reasonml/dependency-env.git"
  },
  "scripts": {},
  "version": "0.1.1"
}
