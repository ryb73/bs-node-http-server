
(* This generated code requires the following version of MenhirLib: *)

let () =
  MenhirLib.StaticVersion.require_20160825

module Basics = struct
  
  exception Error = Parsing.Parse_error
  
  type token = 
    | UID of (string Positions.located)
    | TYPE
    | TOKEN
    | START
    | STAR
    | RPAREN
    | RIGHT
    | QUESTION
    | PUBLIC
    | PREC
    | PLUS
    | PERCENTPERCENT of (Stretch.t Lazy.t)
    | PARAMETER
    | ON_ERROR_REDUCE
    | OCAMLTYPE of (Stretch.ocamltype)
    | NONASSOC
    | LPAREN
    | LID of (string Positions.located)
    | LEFT
    | INLINE
    | HEADER of (Stretch.t)
    | EQUAL
    | EOF
    | COMMA
    | COLON
    | BAR
    | ACTION of (Syntax.identifier option array -> Action.t)
  
end

include Basics

let _eRR =
  Basics.Error
  

open Syntax
open Positions


module Tables = struct
  
  include Basics
  
  let token2terminal : token -> int =
    fun _tok ->
      match _tok with
      | ACTION _ ->
          27
      | BAR ->
          26
      | COLON ->
          25
      | COMMA ->
          24
      | EOF ->
          23
      | EQUAL ->
          22
      | HEADER _ ->
          21
      | INLINE ->
          20
      | LEFT ->
          19
      | LID _ ->
          18
      | LPAREN ->
          17
      | NONASSOC ->
          16
      | OCAMLTYPE _ ->
          15
      | ON_ERROR_REDUCE ->
          14
      | PARAMETER ->
          13
      | PERCENTPERCENT _ ->
          12
      | PLUS ->
          11
      | PREC ->
          10
      | PUBLIC ->
          9
      | QUESTION ->
          8
      | RIGHT ->
          7
      | RPAREN ->
          6
      | STAR ->
          5
      | START ->
          4
      | TOKEN ->
          3
      | TYPE ->
          2
      | UID _ ->
          1
  
  and error_terminal =
    0
  
  and token2value : token -> Obj.t =
    fun _tok ->
      match _tok with
      | ACTION _v ->
          Obj.repr _v
      | BAR ->
          Obj.repr ()
      | COLON ->
          Obj.repr ()
      | COMMA ->
          Obj.repr ()
      | EOF ->
          Obj.repr ()
      | EQUAL ->
          Obj.repr ()
      | HEADER _v ->
          Obj.repr _v
      | INLINE ->
          Obj.repr ()
      | LEFT ->
          Obj.repr ()
      | LID _v ->
          Obj.repr _v
      | LPAREN ->
          Obj.repr ()
      | NONASSOC ->
          Obj.repr ()
      | OCAMLTYPE _v ->
          Obj.repr _v
      | ON_ERROR_REDUCE ->
          Obj.repr ()
      | PARAMETER ->
          Obj.repr ()
      | PERCENTPERCENT _v ->
          Obj.repr _v
      | PLUS ->
          Obj.repr ()
      | PREC ->
          Obj.repr ()
      | PUBLIC ->
          Obj.repr ()
      | QUESTION ->
          Obj.repr ()
      | RIGHT ->
          Obj.repr ()
      | RPAREN ->
          Obj.repr ()
      | STAR ->
          Obj.repr ()
      | START ->
          Obj.repr ()
      | TOKEN ->
          Obj.repr ()
      | TYPE ->
          Obj.repr ()
      | UID _v ->
          Obj.repr _v
  
  and default_reduction =
    (8, "\000\000\000LK\000\000LK\000\000\000&$%\000>J\000!I\000!I\000&$%(\000DJ\007\000*\000\000(\000H\005\000*\000\000(\000B\006.\011\000\t\000\n/-\012\004\014\r\000LK\000\000F\b\000\000\000\018\000\019\000\029\000LK\000\000LK\000\000@\000#\000\000,\000L\000\000K\000\000L\000\000\000\000\031\023\000\000\000LK5\000\000:\000\0008\000\027\000&$%\003\000\000LK3\000\000<\000&$%\000\000\000\031\002\0006\000\000\000LK5\000\000:\000NM\020\001\000\025")
  
  and error =
    (28, "9N\157@\000\016\000@\000 \000\000\000\000\000\000\000\007ÝïÜ@\000 \000\000\000\000\000\000\000\000i\004\b@\000 \000i\000\b\000\000\000\000\000\000\000\000\000\000\004\000\002\000\000\000\000\000\000\000\000\002\000\000\000\000\000\000\000\000\000\000 \000\000\000\000\000\000\000\000\000}Þ½À\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\002\000\000\000\000\000\000\000\000\000\000\000\004\000\016\000\000\000\000\004\000\000\000yN\157À\000\000\000@\000\000\000\000\000\000\000\000\000\000\000\018\000\000\000\000\000\000\002\0009N½À\000\000\000\000\000 \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\016\000\000\000\000\004\000\002\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\004\000\002\000\000\000\000\000\000\000\000yN½Ä\000\002\000\000\000\000\000\000\000\000\000\b\000\004\004\130\144@\000(\000\000\000\000@@ \000\000\000\000@H)\000\000\000\000@\000 \000\000\000\000\000\000\000\000\000\004\004@\000 \000\000\000\000\000\000\000\000 \000\b@\000 \000\000\000\000\002\000\000\000\000\000\000\000\000\000D\002\002\003\000\000\000\004\002\002\003\000\000\000\004K\006#@\000 \000\000\000\000D°`4\002\002\003\000\000\000\004k\006+F°`´\002\002\003\002\000\000\000\000\000\000\000\000\000\000\000\000\001\002 \000¤\000\002\000\000\000\000\000\000\000\000\000\000\000\000 \000\n@  0\000\000\000\000\000\0004\002\002\003\000\000\000\004\002\002\003\000\000\000\004K\002\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000 \0004\000\002\000\000\000\000\000\000\000\000\000\000\000\000 \000\b@  0\000\000\000D° 0\000\000\000\000\000\000\000\000\000\000F° ´k\002\011\002\000\000\000\000\000\000\000\000\000\004K\002\003\000\000\000\000\000\000\001@h)$\000\002\000\000\000\000\000\000\000\000\000\000\000\004\004\130\146@  0\000\000\000\000\b\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\003\148éÔ\000\000\000\000")
  
  and start =
    1
  
  and action =
    ((16, "\000ô\000\r\000j\000\000\000\000\000\003\000¶\000\000\000\000\000\007\000¶\000ô\000\000\000\000\000\000\000¶\000\000\000\000\0000\000\000\000\000\0008\000\000\000\000\0000\000\000\000\000\000\000\000\000\000j\000\000\000\000\000\000\000P\000\000\000v\000\148\000\000\000v\000\000\000\000\000\128\000\000\000`\000Ä\000\000\000`\000\000\000\000\000\000\000\000\000ô\000\000\000j\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Ì\000\000\000\000\000b\000Ì\000\000\000\000\001\024\002\"\000°\000\000\000¾\000\000\002\"\000\000\000ä\000\000\000\000\001\n\001\022\000\000\000\000\000P\001\022\000\000\001:\000\000\001B\002*\000\000\002>\000\000\001\030\001<\000\000\001F\002B\000\000\001\030\001N\002B\001l\000\000\000\000\001P\002$\001B\000\000\000\000\000\000\000B\002>\000\000\000t\002>\000\000\002>\000\000\001¼\000\000\000\000\000\000\000\000\001\002\001J\000\000\000\000\000\000\001`\002B\000\000\001Ì\000\000\000\000\000\000\001~\001\148\001\128\000\000\000\000\001ä\000\000\001d\001ú\001t\000\000\000\000\000\000\002\014\002>\000\000\000\136\000\000\000\000\000\000\000\000\000ô\000\000"), (16, "\000}\000}\000}\000}\000}\000}\000}\000}\000}\000\n\000}\000}\000}\000}\000*\000}\000\026\000}\000}\000}\000}\000}\000}\000}\000}\000\153\001\t\001\t\001\t\000f\000N\001\t\000j\001\t\000Z\000n\001\t\001\t\001\t\000á\001\t\000¡\000\153\001\t\001\t\001\t\000ù\001\t\000r\001\t\000\153\001\017\001\017\001\017\000\014\000\138\001\017\000á\001\017\001Â\000\146\001\017\001\017\001\017\001R\001\017\000²\000\153\001\017\001\017\001\017\000\018\001\017\000r\001\017\000\153\001\025\001\025\001\025\000ª\002g\001\025\000¡\001\025\001Î\000Ù\001\025\001\025\001\025\000=\001\025\002k\000\030\001\025\001\025\001\025\000A\001\025\000\150\001\025\001\001\001\001\001\001\000ú\001&\001\001\000=\001\001\001\030\000\"\001\001\001\001\001\001\000A\001\001\0016\000\153\001\001\001\001\001\001\000þ\001\001\000¶\001\001\000\006\000\134\000¦\0002\000ñ\000Æ\0006\000Ê\001:\000:\000]\000Î\000Ö\000Ò\000Þ\001ö\001F\000â\000æ\000ê\001)\000î\000>\000ò\001)\001)\001B\001)\001\022\001)\001)\000Å\000Å\001J\000\133\001r\001)\001)\001²\001^\000u\001z\001ú\001)\000u\001)\001)\000u\000u\000u\000u\000u\001~\000u\000u\001¶\001\134\000u\000é\001þ\001\150\000u\001f\002J\001\158\000u\000u\000u\000\t\000u\000u\001ª\000\t\000U\002.\000\t\002\n\000\t\000\t\000\005\002N\002B\000\000\000\005\000Q\000\t\000\005\000\000\000\005\000\005\000\000\000U\000\000\000\t\000\t\000\000\000\005\000\000\000\000\000½\000\000\000\000\000Q\001â\000\005\000\005\001æ\000½\000½\001ê\000\000\002\022\000\000\000\000\002\026\000\000\000½\002\030\000\000\000Á\000\000\000\000\000\000\001â\000½\000½\001æ\000\000\000Á\001ê\000Í\000\000\000½\000½\000\000\000\000\000Á\000\000\000Í\002F\000á\000Í\000\000\000\000\000Á\000Á\000\000\000Í\000á\000Í\0009\000á\000Í\000\000\000©\000Í\000Í\000á\001\026\000á\001®\000m\000á\000©\001r\002Z\001\138\0009\000\000\001\"\000\000\000©\000m\000e\000Í\000e\000Í\000\000\000\000\001j\000©\001v\000\000\001\142\000\000\000\000\000\000\000\000\000\000\000e\000e\000e\000e"))
  
  and lhs =
    (8, "\000  \031\031\031\031\031\031\031\031\031\031\031\030\030\030\030\030\029\028\028\028\027\027\026\026\025\025\024\024\023\023\022\022\021\021\021\020\020\019\019\018\018\017\017\017\016\016\015\015\014\014\r\012\012\011\011\n\n\t\t\b\b\007\007\006\006\005\005\004\004\003\003\002\002\001\001")
  
  and goto =
    ((16, "\000\132\000\000\000\003\000\000\000\000\000\025\000(\000\000\000\000\000\004\000r\000\012\000\000\000\000\000\000\000ª\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\030\000\000\000\000\000\000\000\000\000Æ\000\000\000\000\000\000\0000\000\000\000V\000X\000\000\000z\000\000\000\000\000j\000\000\000Ð\000¸\000\000\000Ø\000\000\000\000\000\000\000\000\000\000\000\000\000Ê\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\002\000\000\000\000\000Â\000h\000\000\000\000\000\000\0002\000\000\000\000\000\000\000\000\000l\000\000\000è\000\000\000\000\000Â\000Ô\000\000\000\000\000\000\000Ø\000\000\000\000\000\000\000\000\000Ì\000\000\000J\000\000\000\000\000¼\000\000\000Â\000\005\000\000\000\000\000Ä\000\n\000\000\000\000\000\000\000\000\000\000\000ò\000\000\000\000\000\000\000\000\000v\000\000\000\000\000\148\000\000\000\004\000\000\000Î\000\000\000\000\000\000\000\000\000\000\000ö\000\000\000\000\000\000\000\000\000<\000\000\000Ô\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000Î\000\000\000\000\000\000\000ü\000\000\000\000\000\000\000\000\000\132\000\000\001\000\000\000\000\000\000\000\000\000\000¤\000\000"), (8, "e\006\025Aa!De\139ij\024psvgijvpsv\n\012}\021\130\018w\022\133}e\130x\030 \133Ka\132ij$psv)\143\144\153\150svAM}C\130\n\012a\133}'(\019Kaxrj,psva\152\144L\150sv>M}u\n\012svx}E\017\157a\158x>}\006\025\006\025\031x7T\159T1/\158W0VBPY\\\141\138o|\129\142\137\149\156"))
  
  and semantic_action =
    [|
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = params00;
          MenhirLib.EngineTypes.startp = _startpos_params00_;
          MenhirLib.EngineTypes.endp = _endpos_params00_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = symbol0;
            MenhirLib.EngineTypes.startp = _startpos_symbol0_;
            MenhirLib.EngineTypes.endp = _endpos_symbol0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let params00 : (Syntax.parameters) = Obj.magic params00 in
        let symbol0 : (Syntax.terminal Positions.located) = Obj.magic symbol0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_symbol0_ in
        let _endpos = _endpos_params00_ in
        let _v : (Syntax.parameter) = let p =
          let params0 = params00 in
          let symbol = symbol0 in
          let actuals =
            let params = params0 in
                ( params )
          in
              ( Parameters.app symbol actuals )
        in
            ( p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = m0;
          MenhirLib.EngineTypes.startp = _startpos_m0_;
          MenhirLib.EngineTypes.endp = _endpos_m0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = p0;
            MenhirLib.EngineTypes.startp = _startpos_p0_;
            MenhirLib.EngineTypes.endp = _endpos_p0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let m0 : (Syntax.symbol Positions.located) = Obj.magic m0 in
        let p0 : (Syntax.parameter) = Obj.magic p0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p0_ in
        let _endpos = _endpos_m0_ in
        let _v : (Syntax.parameter) = let p =
          let m = m0 in
          let p = p0 in
              ( ParameterApp (m, [ p ]) )
        in
            ( p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = h;
          MenhirLib.EngineTypes.startp = _startpos_h_;
          MenhirLib.EngineTypes.endp = _endpos_h_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let h : (Stretch.t) = Obj.magic h in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_h_ in
        let _endpos = _endpos_h_ in
        let _v : (Syntax.declaration Positions.located list) = let _endpos = _endpos_h_ in
        let _startpos = _startpos_h_ in
            ( [ with_poss _startpos _endpos (DCode h) ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs0;
          MenhirLib.EngineTypes.startp = _startpos_xs0_;
          MenhirLib.EngineTypes.endp = _endpos_xs0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = t;
            MenhirLib.EngineTypes.startp = _startpos_t_;
            MenhirLib.EngineTypes.endp = _endpos_t_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs0 : (Syntax.terminal Positions.located list) = Obj.magic xs0 in
        let t : (Stretch.ocamltype option) = Obj.magic t in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_xs0_ in
        let _v : (Syntax.declaration Positions.located list) = let ts =
          let xs = xs0 in
              ( xs )
        in
            ( List.map (Positions.map (fun terminal -> DToken (t, terminal))) ts ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs0;
          MenhirLib.EngineTypes.startp = _startpos_xs0_;
          MenhirLib.EngineTypes.endp = _endpos_xs0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = t;
            MenhirLib.EngineTypes.startp = _startpos_t_;
            MenhirLib.EngineTypes.endp = _endpos_t_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs0 : (Syntax.nonterminal Positions.located list) = Obj.magic xs0 in
        let t : (Stretch.ocamltype option) = Obj.magic t in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_xs0_ in
        let _v : (Syntax.declaration Positions.located list) = let nts =
          let xs = xs0 in
              ( xs )
        in
            (
      match t with
      | None ->
          List.map (Positions.map (fun nonterminal -> DStart nonterminal)) nts
      | Some t ->
          Misc.mapd (fun ntloc ->
            Positions.mapd (fun nt -> DStart nt, DType (t, ParameterVar ntloc)) ntloc) nts
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs0;
          MenhirLib.EngineTypes.startp = _startpos_xs0_;
          MenhirLib.EngineTypes.endp = _endpos_xs0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = t;
            MenhirLib.EngineTypes.startp = _startpos_t_;
            MenhirLib.EngineTypes.endp = _endpos_t_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _1;
              MenhirLib.EngineTypes.startp = _startpos__1_;
              MenhirLib.EngineTypes.endp = _endpos__1_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs0 : (Syntax.parameter list) = Obj.magic xs0 in
        let t : (Stretch.ocamltype) = Obj.magic t in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_xs0_ in
        let _v : (Syntax.declaration Positions.located list) = let ss =
          let xs = xs0 in
              ( xs )
        in
            ( List.map (Positions.map (fun nt -> DType (t, nt)))
        (List.map Parameters.with_pos ss) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs0;
          MenhirLib.EngineTypes.startp = _startpos_xs0_;
          MenhirLib.EngineTypes.endp = _endpos_xs0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = k;
            MenhirLib.EngineTypes.startp = _startpos_k_;
            MenhirLib.EngineTypes.endp = _endpos_k_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let xs0 : (Syntax.terminal Positions.located list) = Obj.magic xs0 in
        let k : (Syntax.token_associativity) = Obj.magic k in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_k_ in
        let _endpos = _endpos_xs0_ in
        let _v : (Syntax.declaration Positions.located list) = let ss =
          let xs = xs0 in
              ( xs )
        in
            ( let prec = ParserAux.new_precedence_level _startpos_k_ _endpos_k_ in
      List.map (Positions.map (fun symbol -> DTokenProperties (symbol, k, prec))) ss ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = t;
          MenhirLib.EngineTypes.startp = _startpos_t_;
          MenhirLib.EngineTypes.endp = _endpos_t_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let t : (Stretch.ocamltype) = Obj.magic t in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_t_ in
        let _v : (Syntax.declaration Positions.located list) = let _endpos = _endpos_t_ in
        let _startpos = _startpos__1_ in
            ( [ with_poss _startpos _endpos (DParameter t) ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs0;
          MenhirLib.EngineTypes.startp = _startpos_xs0_;
          MenhirLib.EngineTypes.endp = _endpos_xs0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let xs0 : (Syntax.parameter list) = Obj.magic xs0 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos_xs0_ in
        let _v : (Syntax.declaration Positions.located list) = let ss =
          let xs = xs0 in
              ( xs )
        in
            ( let prec = ParserAux.new_on_error_reduce_level() in
      List.map (Positions.map (fun nt -> DOnErrorReduce (nt, prec)))
        (List.map Parameters.with_pos ss) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (Syntax.declaration Positions.located list) = let _1 =
          let _1 = _10 in
              ( () )
        in
        let _endpos__1_ = _endpos__10_ in
        let _startpos__1_ = _startpos__10_ in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
            (
      Error.error (Positions.two _startpos _endpos)
        "syntax error inside a declaration.\n\
         Did you perhaps forget the %%%% that separates declarations and rules?"
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (Syntax.declaration Positions.located list) = let _1 =
          let _1 = _10 in
              ( () )
        in
        let _endpos__1_ = _endpos__10_ in
        let _startpos__1_ = _startpos__10_ in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
            (
      Error.error (Positions.two _startpos _endpos)
        "syntax error inside a declaration.\n\
         Did you perhaps forget the %%%% that separates declarations and rules?"
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (Syntax.declaration Positions.located list) = let _1 =
          let _1 = _10 in
              ( () )
        in
        let _endpos__1_ = _endpos__10_ in
        let _startpos__1_ = _startpos__10_ in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
            (
      Error.error (Positions.two _startpos _endpos)
        "syntax error inside a declaration.\n\
         Did you perhaps forget the %%%% that separates declarations and rules?"
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _10;
          MenhirLib.EngineTypes.startp = _startpos__10_;
          MenhirLib.EngineTypes.endp = _endpos__10_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__10_ in
        let _v : (Syntax.declaration Positions.located list) = let _1 =
          let _1 = _10 in
              ( () )
        in
        let _endpos__1_ = _endpos__10_ in
        let _startpos__1_ = _startpos__10_ in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
            (
      Error.error (Positions.two _startpos _endpos)
        "syntax error inside a declaration.\n\
         Did you perhaps forget the %%%% that separates declarations and rules?"
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (bool * bool) =     ( false, false ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (bool * bool) =     ( true, false ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (bool * bool) =     ( false, true ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (bool * bool) =     ( true, true ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _2;
          MenhirLib.EngineTypes.startp = _startpos__2_;
          MenhirLib.EngineTypes.endp = _endpos__2_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = _1;
            MenhirLib.EngineTypes.startp = _startpos__1_;
            MenhirLib.EngineTypes.endp = _endpos__1_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let _2 : unit = Obj.magic _2 in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__2_ in
        let _v : (bool * bool) =     ( true, true ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = t;
          MenhirLib.EngineTypes.startp = _startpos_t_;
          MenhirLib.EngineTypes.endp = _endpos_t_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = rs;
            MenhirLib.EngineTypes.startp = _startpos_rs_;
            MenhirLib.EngineTypes.endp = _endpos_rs_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _2;
              MenhirLib.EngineTypes.startp = _startpos__2_;
              MenhirLib.EngineTypes.endp = _endpos__2_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = ds;
                MenhirLib.EngineTypes.startp = _startpos_ds_;
                MenhirLib.EngineTypes.endp = _endpos_ds_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let t : (Syntax.trailer option) = Obj.magic t in
        let rs : (Syntax.parameterized_rule list) = Obj.magic rs in
        let _2 : (Stretch.t Lazy.t) = Obj.magic _2 in
        let ds : (Syntax.declaration Positions.located list list) = Obj.magic ds in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_ds_ in
        let _endpos = _endpos_t_ in
        let _v : (Syntax.partial_grammar) =     (
      {
        pg_filename          = ""; (* filled in by the caller *)
        pg_declarations      = List.flatten ds;
        pg_rules             = rs;
        pg_trailer           = t
      }
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = params00;
          MenhirLib.EngineTypes.startp = _startpos_params00_;
          MenhirLib.EngineTypes.endp = _endpos_params00_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = symbol0;
            MenhirLib.EngineTypes.startp = _startpos_symbol0_;
            MenhirLib.EngineTypes.endp = _endpos_symbol0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let params00 : (Syntax.parameters) = Obj.magic params00 in
        let symbol0 : (Syntax.terminal Positions.located) = Obj.magic symbol0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_symbol0_ in
        let _endpos = _endpos_params00_ in
        let _v : (Syntax.parameter) = let p =
          let params0 = params00 in
          let symbol = symbol0 in
          let actuals =
            let params = params0 in
                ( params )
          in
              ( Parameters.app symbol actuals )
        in
            ( p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = m0;
          MenhirLib.EngineTypes.startp = _startpos_m0_;
          MenhirLib.EngineTypes.endp = _endpos_m0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = p0;
            MenhirLib.EngineTypes.startp = _startpos_p0_;
            MenhirLib.EngineTypes.endp = _endpos_p0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let m0 : (Syntax.symbol Positions.located) = Obj.magic m0 in
        let p0 : (Syntax.parameter) = Obj.magic p0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p0_ in
        let _endpos = _endpos_m0_ in
        let _v : (Syntax.parameter) = let p =
          let m = m0 in
          let p = p0 in
              ( ParameterApp (m, [ p ]) )
        in
            ( p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = prods0;
          MenhirLib.EngineTypes.startp = _startpos_prods0_;
          MenhirLib.EngineTypes.endp = _endpos_prods0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let prods0 : (Syntax.parameterized_branch list list) = Obj.magic prods0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_prods0_ in
        let _endpos = _endpos_prods0_ in
        let _v : (Syntax.parameter) = let branches =
          let prods = prods0 in
              ( List.flatten prods )
        in
        let _endpos_branches_ = _endpos_prods0_ in
        let _startpos_branches_ = _startpos_prods0_ in
        let _endpos = _endpos_branches_ in
        let _startpos = _startpos_branches_ in
            ( ParameterAnonymous (with_poss _startpos _endpos branches) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Syntax.declaration Positions.located list list) =     ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x;
            MenhirLib.EngineTypes.startp = _startpos_x_;
            MenhirLib.EngineTypes.endp = _endpos_x_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let xs : (Syntax.declaration Positions.located list list) = Obj.magic xs in
        let x : (Syntax.declaration Positions.located list) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.declaration Positions.located list list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list) =     ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x;
            MenhirLib.EngineTypes.startp = _startpos_x_;
            MenhirLib.EngineTypes.endp = _endpos_x_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let xs : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list) = Obj.magic xs in
        let x : (Positions.t * Syntax.identifier Positions.located option * Syntax.parameter) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Syntax.parameterized_rule list) =     ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = x;
            MenhirLib.EngineTypes.startp = _startpos_x_;
            MenhirLib.EngineTypes.endp = _endpos_x_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let xs : (Syntax.parameterized_rule list) = Obj.magic xs in
        let x : (Syntax.parameterized_rule) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.parameterized_rule list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Syntax.parameters) =     ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _30;
          MenhirLib.EngineTypes.startp = _startpos__30_;
          MenhirLib.EngineTypes.endp = _endpos__30_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _10;
              MenhirLib.EngineTypes.startp = _startpos__10_;
              MenhirLib.EngineTypes.endp = _endpos__10_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _30 : unit = Obj.magic _30 in
        let x0 : (Syntax.parameters) = Obj.magic x0 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__30_ in
        let _v : (Syntax.parameters) = let x =
          let _3 = _30 in
          let x = x0 in
          let _1 = _10 in
              ( x )
        in
            ( x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Syntax.parameters) =     ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _30;
          MenhirLib.EngineTypes.startp = _startpos__30_;
          MenhirLib.EngineTypes.endp = _endpos__30_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _10;
              MenhirLib.EngineTypes.startp = _startpos__10_;
              MenhirLib.EngineTypes.endp = _endpos__10_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _30 : unit = Obj.magic _30 in
        let x0 : (Syntax.parameters) = Obj.magic x0 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__30_ in
        let _v : (Syntax.parameters) = let x =
          let _3 = _30 in
          let x = x0 in
          let _1 = _10 in
              ( x )
        in
            ( x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Syntax.terminal Positions.located list) =     ( [] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = _30;
          MenhirLib.EngineTypes.startp = _startpos__30_;
          MenhirLib.EngineTypes.endp = _endpos__30_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = x0;
            MenhirLib.EngineTypes.startp = _startpos_x0_;
            MenhirLib.EngineTypes.endp = _endpos_x0_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = _10;
              MenhirLib.EngineTypes.startp = _startpos__10_;
              MenhirLib.EngineTypes.endp = _endpos__10_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let _30 : unit = Obj.magic _30 in
        let x0 : (Syntax.terminal Positions.located list) = Obj.magic x0 in
        let _10 : unit = Obj.magic _10 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__10_ in
        let _endpos = _endpos__30_ in
        let _v : (Syntax.terminal Positions.located list) = let x =
          let _3 = _30 in
          let x = x0 in
          let _1 = _10 in
              ( x )
        in
            ( x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Syntax.symbol Positions.located) = let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
            ( with_poss _startpos _endpos "option" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Syntax.symbol Positions.located) = let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
            ( with_poss _startpos _endpos "nonempty_list" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Syntax.symbol Positions.located) = let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
            ( with_poss _startpos _endpos "list" ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit option) =     ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : unit = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (unit option) =     ( Some x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (Stretch.ocamltype option) =     ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Stretch.ocamltype) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Stretch.ocamltype option) =     ( Some x ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let _menhir_s = _menhir_env.MenhirLib.EngineTypes.current in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _endpos = _startpos in
        let _v : (unit) =     ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (unit) =     ( () ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Syntax.token_associativity) =     ( LeftAssoc ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Syntax.token_associativity) =     ( RightAssoc ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Syntax.token_associativity) =     ( NonAssoc ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = p;
          MenhirLib.EngineTypes.startp = _startpos_p_;
          MenhirLib.EngineTypes.endp = _endpos_p_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let p : (Syntax.parameter) = Obj.magic p in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p_ in
        let _endpos = _endpos_p_ in
        let _v : (Positions.t * Syntax.identifier Positions.located option * Syntax.parameter) = let id =
              ( None )
        in
        let _startpos_id_ = _endpos__0_ in
        let _endpos = _endpos_p_ in
        let _startpos = _startpos_id_ in
            ( position (with_poss _startpos _endpos ()), id, p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = p;
          MenhirLib.EngineTypes.startp = _startpos_p_;
          MenhirLib.EngineTypes.endp = _endpos_p_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _200;
            MenhirLib.EngineTypes.startp = _startpos__200_;
            MenhirLib.EngineTypes.endp = _endpos__200_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x00;
              MenhirLib.EngineTypes.startp = _startpos_x00_;
              MenhirLib.EngineTypes.endp = _endpos_x00_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let p : (Syntax.parameter) = Obj.magic p in
        let _200 : unit = Obj.magic _200 in
        let x00 : (string Positions.located) = Obj.magic x00 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x00_ in
        let _endpos = _endpos_p_ in
        let _v : (Positions.t * Syntax.identifier Positions.located option * Syntax.parameter) = let id =
          let _20 = _200 in
          let x0 = x00 in
          let x =
            let _2 = _20 in
            let x = x0 in
                ( x )
          in
              ( Some x )
        in
        let _startpos_id_ = _startpos_x00_ in
        let _endpos = _endpos_p_ in
        let _startpos = _startpos_id_ in
            ( position (with_poss _startpos _endpos ()), id, p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = producers;
          MenhirLib.EngineTypes.startp = _startpos_producers_;
          MenhirLib.EngineTypes.endp = _endpos_producers_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let producers : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list) = Obj.magic producers in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_producers_ in
        let _endpos = _endpos_producers_ in
        let _v : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list * Syntax.terminal Positions.located option *
  Syntax.branch_production_level * Positions.t) = let oprec =
              ( None )
        in
        let _endpos_oprec_ = _endpos_producers_ in
        let _endpos = _endpos_oprec_ in
        let _startpos = _startpos_producers_ in
            ( producers,
      oprec,
      ParserAux.new_production_level(),
      Positions.lex_join _startpos _endpos
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = symbol00;
          MenhirLib.EngineTypes.startp = _startpos_symbol00_;
          MenhirLib.EngineTypes.endp = _endpos_symbol00_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = producers;
              MenhirLib.EngineTypes.startp = _startpos_producers_;
              MenhirLib.EngineTypes.endp = _endpos_producers_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let symbol00 : (Syntax.terminal Positions.located) = Obj.magic symbol00 in
        let _100 : unit = Obj.magic _100 in
        let producers : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list) = Obj.magic producers in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_producers_ in
        let _endpos = _endpos_symbol00_ in
        let _v : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list * Syntax.terminal Positions.located option *
  Syntax.branch_production_level * Positions.t) = let oprec =
          let symbol0 = symbol00 in
          let _10 = _100 in
          let x =
            let symbol = symbol0 in
            let _1 = _10 in
                ( symbol )
          in
              ( Some x )
        in
        let _endpos_oprec_ = _endpos_symbol00_ in
        let _endpos = _endpos_oprec_ in
        let _startpos = _startpos_producers_ in
            ( producers,
      oprec,
      ParserAux.new_production_level(),
      Positions.lex_join _startpos _endpos
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = action;
          MenhirLib.EngineTypes.startp = _startpos_action_;
          MenhirLib.EngineTypes.endp = _endpos_action_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = productions;
            MenhirLib.EngineTypes.startp = _startpos_productions_;
            MenhirLib.EngineTypes.endp = _endpos_productions_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let action : (Syntax.identifier option array -> Action.t) = Obj.magic action in
        let productions : (((Positions.t * Syntax.identifier Positions.located option *
    Syntax.parameter)
   list * Syntax.terminal Positions.located option *
   Syntax.branch_production_level * Positions.t)
  list) = Obj.magic productions in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_productions_ in
        let _endpos = _endpos_action_ in
        let _v : (Syntax.parameterized_branch list) = let oprec2 =
              ( None )
        in
            (
      (* If multiple productions share a single semantic action, check
         that all of them bind the same names. *)
      ParserAux.check_production_group productions;
      (* Then, *)
      List.map (fun (producers, oprec1, level, pos) ->
        (* Replace [$i] with [_i]. *)
        let pr_producers = ParserAux.normalize_producers producers in
        (* Distribute the semantic action. Also, check that every [$i]
           is within bounds. *)
        let action : Syntax.identifier option array -> Action.t = action in
        let pr_action = action (ParserAux.producer_names producers) in
        {
          pr_producers;
          pr_action;
          pr_branch_prec_annotation   = ParserAux.override pos oprec1 oprec2;
          pr_branch_production_level  = level;
          pr_branch_position          = pos
        })
      productions
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = symbol00;
          MenhirLib.EngineTypes.startp = _startpos_symbol00_;
          MenhirLib.EngineTypes.endp = _endpos_symbol00_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _100;
            MenhirLib.EngineTypes.startp = _startpos__100_;
            MenhirLib.EngineTypes.endp = _endpos__100_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = action;
              MenhirLib.EngineTypes.startp = _startpos_action_;
              MenhirLib.EngineTypes.endp = _endpos_action_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.state = _menhir_s;
                MenhirLib.EngineTypes.semv = productions;
                MenhirLib.EngineTypes.startp = _startpos_productions_;
                MenhirLib.EngineTypes.endp = _endpos_productions_;
                MenhirLib.EngineTypes.next = _menhir_stack;
              };
            };
          };
        } = _menhir_stack in
        let symbol00 : (Syntax.terminal Positions.located) = Obj.magic symbol00 in
        let _100 : unit = Obj.magic _100 in
        let action : (Syntax.identifier option array -> Action.t) = Obj.magic action in
        let productions : (((Positions.t * Syntax.identifier Positions.located option *
    Syntax.parameter)
   list * Syntax.terminal Positions.located option *
   Syntax.branch_production_level * Positions.t)
  list) = Obj.magic productions in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_productions_ in
        let _endpos = _endpos_symbol00_ in
        let _v : (Syntax.parameterized_branch list) = let oprec2 =
          let symbol0 = symbol00 in
          let _10 = _100 in
          let x =
            let symbol = symbol0 in
            let _1 = _10 in
                ( symbol )
          in
              ( Some x )
        in
            (
      (* If multiple productions share a single semantic action, check
         that all of them bind the same names. *)
      ParserAux.check_production_group productions;
      (* Then, *)
      List.map (fun (producers, oprec1, level, pos) ->
        (* Replace [$i] with [_i]. *)
        let pr_producers = ParserAux.normalize_producers producers in
        (* Distribute the semantic action. Also, check that every [$i]
           is within bounds. *)
        let action : Syntax.identifier option array -> Action.t = action in
        let pr_action = action (ParserAux.producer_names producers) in
        {
          pr_producers;
          pr_action;
          pr_branch_prec_annotation   = ParserAux.override pos oprec1 oprec2;
          pr_branch_production_level  = level;
          pr_branch_position          = pos
        })
      productions
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = prods0;
          MenhirLib.EngineTypes.startp = _startpos_prods0_;
          MenhirLib.EngineTypes.endp = _endpos_prods0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _5;
            MenhirLib.EngineTypes.startp = _startpos__5_;
            MenhirLib.EngineTypes.endp = _endpos__5_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.semv = _4;
              MenhirLib.EngineTypes.startp = _startpos__4_;
              MenhirLib.EngineTypes.endp = _endpos__4_;
              MenhirLib.EngineTypes.next = {
                MenhirLib.EngineTypes.semv = params0;
                MenhirLib.EngineTypes.startp = _startpos_params0_;
                MenhirLib.EngineTypes.endp = _endpos_params0_;
                MenhirLib.EngineTypes.next = {
                  MenhirLib.EngineTypes.semv = symbol;
                  MenhirLib.EngineTypes.startp = _startpos_symbol_;
                  MenhirLib.EngineTypes.endp = _endpos_symbol_;
                  MenhirLib.EngineTypes.next = {
                    MenhirLib.EngineTypes.state = _menhir_s;
                    MenhirLib.EngineTypes.semv = flags;
                    MenhirLib.EngineTypes.startp = _startpos_flags_;
                    MenhirLib.EngineTypes.endp = _endpos_flags_;
                    MenhirLib.EngineTypes.next = _menhir_stack;
                  };
                };
              };
            };
          };
        } = _menhir_stack in
        let prods0 : (Syntax.parameterized_branch list list) = Obj.magic prods0 in
        let _5 : (unit) = Obj.magic _5 in
        let _4 : unit = Obj.magic _4 in
        let params0 : (Syntax.terminal Positions.located list) = Obj.magic params0 in
        let symbol : (Syntax.terminal Positions.located) = Obj.magic symbol in
        let flags : (bool * bool) = Obj.magic flags in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_flags_ in
        let _endpos = _endpos_prods0_ in
        let _v : (Syntax.parameterized_rule) = let branches =
          let prods = prods0 in
              ( List.flatten prods )
        in
        let params =
          let params = params0 in
              ( params )
        in
            (
      let public, inline = flags in
      {
        pr_public_flag = public;
        pr_inline_flag = inline;
        pr_nt          = Positions.value symbol;
        pr_positions   = [ Positions.position symbol ];
        pr_parameters  = List.map Positions.value params;
        pr_branches    = branches
      }
    ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list * Syntax.terminal Positions.located option *
  Syntax.branch_production_level * Positions.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (((Positions.t * Syntax.identifier Positions.located option *
    Syntax.parameter)
   list * Syntax.terminal Positions.located option *
   Syntax.branch_production_level * Positions.t)
  list) =     ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (((Positions.t * Syntax.identifier Positions.located option *
    Syntax.parameter)
   list * Syntax.terminal Positions.located option *
   Syntax.branch_production_level * Positions.t)
  list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : ((Positions.t * Syntax.identifier Positions.located option *
   Syntax.parameter)
  list * Syntax.terminal Positions.located option *
  Syntax.branch_production_level * Positions.t) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (((Positions.t * Syntax.identifier Positions.located option *
    Syntax.parameter)
   list * Syntax.terminal Positions.located option *
   Syntax.branch_production_level * Positions.t)
  list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Syntax.parameterized_branch list) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Syntax.parameterized_branch list list) =     ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.parameterized_branch list list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (Syntax.parameterized_branch list) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.parameterized_branch list list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Syntax.parameter) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Syntax.parameters) =     ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.parameters) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (Syntax.parameter) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.parameters) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Syntax.parameter) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Syntax.parameters) =     ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.parameters) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (Syntax.parameter) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.parameters) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Syntax.terminal Positions.located) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Syntax.terminal Positions.located list) =     ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.terminal Positions.located list) = Obj.magic xs in
        let _2 : unit = Obj.magic _2 in
        let x : (Syntax.terminal Positions.located) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.terminal Positions.located list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = id0;
          MenhirLib.EngineTypes.startp = _startpos_id0_;
          MenhirLib.EngineTypes.endp = _endpos_id0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let id0 : (string Positions.located) = Obj.magic id0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id0_ in
        let _endpos = _endpos_id0_ in
        let _v : (Syntax.nonterminal Positions.located list) = let x =
          let id = id0 in
              ( id )
        in
            ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = id0;
              MenhirLib.EngineTypes.startp = _startpos_id0_;
              MenhirLib.EngineTypes.endp = _endpos_id0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.nonterminal Positions.located list) = Obj.magic xs in
        let _2 : (unit option) = Obj.magic _2 in
        let id0 : (string Positions.located) = Obj.magic id0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id0_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.nonterminal Positions.located list) = let x =
          let id = id0 in
              ( id )
        in
            ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Syntax.parameter) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Syntax.parameter list) =     ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.parameter list) = Obj.magic xs in
        let _2 : (unit option) = Obj.magic _2 in
        let x : (Syntax.parameter) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.parameter list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = x;
          MenhirLib.EngineTypes.startp = _startpos_x_;
          MenhirLib.EngineTypes.endp = _endpos_x_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let x : (Syntax.terminal Positions.located) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_x_ in
        let _v : (Syntax.terminal Positions.located list) =     ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = x;
              MenhirLib.EngineTypes.startp = _startpos_x_;
              MenhirLib.EngineTypes.endp = _endpos_x_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.terminal Positions.located list) = Obj.magic xs in
        let _2 : (unit option) = Obj.magic _2 in
        let x : (Syntax.terminal Positions.located) = Obj.magic x in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_x_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.terminal Positions.located list) =     ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = id0;
          MenhirLib.EngineTypes.startp = _startpos_id0_;
          MenhirLib.EngineTypes.endp = _endpos_id0_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let id0 : (string Positions.located) = Obj.magic id0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id0_ in
        let _endpos = _endpos_id0_ in
        let _v : (Syntax.terminal Positions.located list) = let x =
          let id = id0 in
              ( id )
        in
            ( [ x ] ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = xs;
          MenhirLib.EngineTypes.startp = _startpos_xs_;
          MenhirLib.EngineTypes.endp = _endpos_xs_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.semv = _2;
            MenhirLib.EngineTypes.startp = _startpos__2_;
            MenhirLib.EngineTypes.endp = _endpos__2_;
            MenhirLib.EngineTypes.next = {
              MenhirLib.EngineTypes.state = _menhir_s;
              MenhirLib.EngineTypes.semv = id0;
              MenhirLib.EngineTypes.startp = _startpos_id0_;
              MenhirLib.EngineTypes.endp = _endpos_id0_;
              MenhirLib.EngineTypes.next = _menhir_stack;
            };
          };
        } = _menhir_stack in
        let xs : (Syntax.terminal Positions.located list) = Obj.magic xs in
        let _2 : (unit option) = Obj.magic _2 in
        let id0 : (string Positions.located) = Obj.magic id0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id0_ in
        let _endpos = _endpos_xs_ in
        let _v : (Syntax.terminal Positions.located list) = let x =
          let id = id0 in
              ( id )
        in
            ( x :: xs ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = params00;
          MenhirLib.EngineTypes.startp = _startpos_params00_;
          MenhirLib.EngineTypes.endp = _endpos_params00_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = symbol0;
            MenhirLib.EngineTypes.startp = _startpos_symbol0_;
            MenhirLib.EngineTypes.endp = _endpos_symbol0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let params00 : (Syntax.parameters) = Obj.magic params00 in
        let symbol0 : (Syntax.terminal Positions.located) = Obj.magic symbol0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_symbol0_ in
        let _endpos = _endpos_params00_ in
        let _v : (Syntax.parameter) = let p =
          let params0 = params00 in
          let symbol = symbol0 in
          let actuals =
            let params = params0 in
                ( params )
          in
              ( Parameters.app symbol actuals )
        in
            ( p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.semv = m0;
          MenhirLib.EngineTypes.startp = _startpos_m0_;
          MenhirLib.EngineTypes.endp = _endpos_m0_;
          MenhirLib.EngineTypes.next = {
            MenhirLib.EngineTypes.state = _menhir_s;
            MenhirLib.EngineTypes.semv = p0;
            MenhirLib.EngineTypes.startp = _startpos_p0_;
            MenhirLib.EngineTypes.endp = _endpos_p0_;
            MenhirLib.EngineTypes.next = _menhir_stack;
          };
        } = _menhir_stack in
        let m0 : (Syntax.symbol Positions.located) = Obj.magic m0 in
        let p0 : (Syntax.parameter) = Obj.magic p0 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p0_ in
        let _endpos = _endpos_m0_ in
        let _v : (Syntax.parameter) = let p =
          let m = m0 in
          let p = p0 in
              ( ParameterApp (m, [ p ]) )
        in
            ( p ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = id;
          MenhirLib.EngineTypes.startp = _startpos_id_;
          MenhirLib.EngineTypes.endp = _endpos_id_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let id : (string Positions.located) = Obj.magic id in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id_ in
        let _endpos = _endpos_id_ in
        let _v : (Syntax.terminal Positions.located) =     ( id ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = id;
          MenhirLib.EngineTypes.startp = _startpos_id_;
          MenhirLib.EngineTypes.endp = _endpos_id_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let id : (string Positions.located) = Obj.magic id in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_id_ in
        let _endpos = _endpos_id_ in
        let _v : (Syntax.terminal Positions.located) =     ( id ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = _1;
          MenhirLib.EngineTypes.startp = _startpos__1_;
          MenhirLib.EngineTypes.endp = _endpos__1_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let _1 : unit = Obj.magic _1 in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos__1_ in
        let _endpos = _endpos__1_ in
        let _v : (Syntax.trailer option) =     ( None ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
      (fun _menhir_env ->
        let _menhir_stack = _menhir_env.MenhirLib.EngineTypes.stack in
        let {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = p;
          MenhirLib.EngineTypes.startp = _startpos_p_;
          MenhirLib.EngineTypes.endp = _endpos_p_;
          MenhirLib.EngineTypes.next = _menhir_stack;
        } = _menhir_stack in
        let p : (Stretch.t Lazy.t) = Obj.magic p in
        let _endpos__0_ = _menhir_stack.MenhirLib.EngineTypes.endp in
        let _startpos = _startpos_p_ in
        let _endpos = _endpos_p_ in
        let _v : (Syntax.trailer option) =     ( Some (Lazy.force p) ) in
        {
          MenhirLib.EngineTypes.state = _menhir_s;
          MenhirLib.EngineTypes.semv = Obj.repr _v;
          MenhirLib.EngineTypes.startp = _startpos;
          MenhirLib.EngineTypes.endp = _endpos;
          MenhirLib.EngineTypes.next = _menhir_stack;
        });
    |]
  
  and trace =
    None
  
end

module MenhirInterpreter = struct
  
  module TI = MenhirLib.TableInterpreter.Make (Tables)
  
  include TI
  
end

let grammar =
  fun lexer lexbuf ->
    (Obj.magic (MenhirInterpreter.entry 0 lexer lexbuf) : (Syntax.partial_grammar))

module Incremental = struct
  
  let grammar =
    fun initial_position ->
      (Obj.magic (MenhirInterpreter.start 0 initial_position) : (Syntax.partial_grammar) MenhirInterpreter.checkpoint)
  
end
  
  

